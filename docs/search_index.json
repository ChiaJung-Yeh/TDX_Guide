[["運輸資料應用.html", "Chapter 7 運輸資料應用 7.1 計算公車站點間旅行距離", " Chapter 7 運輸資料應用 本章節主要示範運輸資料於實務場域中的應用。 7.1 計算公車站點間旅行距離 本節透過 TDX 公車站牌與路線圖資，建立演算法計算各站牌的累積里程，進而計算站點間旅行距離（簡報）。 7.1.1 目的 站點間距離可用以反映任兩站點間公車行駛的實際里程，該數據可進一步與 TDX 歷史資料中的行駛時間（Bus_TravelTime()）或公車歷史動態資料（Bus_RealTime()）對應，以計算各區間的平均速度，尋找公車各時段阻塞的區間，進而提出相對應的改善方式。在 GTFS 格式中，里程資訊為必備欄位，如是可依據各站點的累積里程推算任兩站點間的距離。然而 TDX 的公車站點資料（Bus_StopOfRoute）中並未提供該數據，進而無法計算站點間距離。其一解決方式是將各站點的經緯度輸入至地圖路徑規劃的 API 中，尋找公共運輸的最佳路徑，然而此一方法並不能確保所選擇的運具為特定公車路線；若以私有運具的路徑概似之，其缺點乃公車路線並不確保是最短距離，乃因受限於公車營運之限制或提升服務可及性，站點間距離可能大於兩點間的最短路徑長度。此外，使用地圖 API 曠日廢時或所需費用甚高，因此實務上可能並不合適。綜上所述，本節將建構一套演算法，透過 TDX 既有的公車路線圖資（Bus_Shape()）與公車站牌圖資（Bus_StopOfRoute()）切分數個站牌間的區間，依此計算各區間的長度即為站點間旅行距離。由於公車站點並不一定落於公車路線上（通常不可能是），故必須先行地圖匹配（map-matching），本演算法中簡單應用 Paul Newson 與 John Krumm 所提出之先進地圖匹配法（advanced map-matching），將所有公車站牌定位至路線上，以便於拆分並計算累積里程。 7.1.2 使用資料與函式 library(TDX) # TDX 套件中應用函式 Bus_Route() Bus_Shape() Bus_StopOfRoute() 7.1.3 演算概念與步驟 本演算法步驟如圖7.1所示。圖中綠色點為公車站牌，藍色線段為公車路線，首先將公車站牌匹配至公車路線上，並依此切分公車路線，最後計算兩站牌間的距離即可得站間旅行距離。 圖 7.1: 演算法步驟示意圖 請注意此演算法仍會產出部分錯誤的結果，須另行檢查，計算結果的優劣取決於原始 TDX 路線圖資的品質，如雙北市的公車路線圖資出現許多錯誤繞行、數化順序錯誤、SubRouteUID 錯誤對應等情形，導致計算結果錯誤甚大。因此本節以路線品質相對較佳的基隆市市區公車作為範例。 步驟零：介接公車資料 透過 TDX 套件介接公車路線、公車站牌、公車路線圖資三份資料。 access_token=get_token(client_id, client_secret) #---介接資料---# # 公車路線資訊 bus_route=Bus_Route(access_token, &quot;Keelung&quot;) # 公車站牌 bus_shape=Bus_Shape(access_token, &quot;Keelung&quot;, dtype=&quot;sf&quot;)%&gt;% st_transform(crs=3826) # 公車路線圖資 bus_stop=Bus_StopOfRoute(access_token, &quot;Keelung&quot;, dtype=&quot;sf&quot;)%&gt;% st_transform(crs=3826) #---以第一條為範例---# bus_shape_temp=filter(bus_shape, SubRouteUID==bus_route$SubRouteUID[1]) bus_stop_temp=filter(bus_stop, SubRouteUID==bus_route$SubRouteUID[1], Direction==bus_route$Direction[1]) tm_shape(bus_shape_temp)+ tm_lines()+ tm_shape(bus_stop_temp)+ tm_dots() 由地圖可見，公車站牌大多未落於公車路線上，故本演算法必須先行透過地圖匹配將點位移至路線上！ 步驟一：拆分公車路線之線段 依據直線將原始公車圖資切分成數個直線段。先利用st_coordinate()將路線所有轉折點全數萃取出。演算法如圖7.2所示。 需注意的是，本演算法的執行係假設路線圖資是依據公車路線由第一站至最後一站方式數化，故部分縣市（如雙北市）公車路線若未依據此一原則數化，則演算法將出現諸多謬誤。 圖 7.2: 拆分公車路線示意圖 # 拆分公車路線之線段 bus_shape_coord=data.frame(st_coordinates(bus_shape_temp)[, c(1:2)])%&gt;% mutate(geometry=st_as_sfc(paste0(&quot;POINT(&quot;, X, &quot; &quot;, Y, &quot;)&quot;)))%&gt;% st_sf(crs=3826) dist_point=as.numeric(st_distance(bus_shape_coord[1:(nrow(bus_shape_coord)-1),], bus_shape_coord[2:(nrow(bus_shape_coord)),], by_element=T)) tm_shape(bus_shape_temp)+ tm_lines()+ tm_shape(bus_stop_temp)+ tm_dots()+ tm_shape(bus_shape_coord)+ tm_dots(col=&quot;blue&quot;) 步驟二：將各路段細分 由於直線段可能很長，致使後續點為匹配過於粗糙，並非最接近的點位，故須將步驟一切分完成的路段再細分為至多每 10 公尺之路段，確保精確匹配。 圖 7.3: 公車路段細分示意圖 # 將各路段細分為至多每10公尺一段(使配對更為精確) all_point=data.frame() for(i in c(1:nrow(bus_shape_coord))){ if(i!=nrow(bus_shape_coord)){ new_int_num=ceiling(dist_point[i]/10) if(new_int_num&gt;1){ new_point=data.frame(X=mapply(function(x) bus_shape_coord$X[i]+((bus_shape_coord$X[i+1]-bus_shape_coord$X[i])/new_int_num)*x, c(1:(new_int_num-1))), Y=mapply(function(x) bus_shape_coord$Y[i]+((bus_shape_coord$Y[i+1]-bus_shape_coord$Y[i])/new_int_num)*x, c(1:(new_int_num-1)))) temp_point=rbind(data.frame(X=bus_shape_coord$X[i], Y=bus_shape_coord$Y[i]), new_point) all_point=rbind(all_point, temp_point) }else{ all_point=rbind(all_point, data.frame(X=bus_shape_coord$X[i], Y=bus_shape_coord$Y[i])) } }else{ all_point=rbind(all_point, data.frame(X=bus_shape_coord$X[i], Y=bus_shape_coord$Y[i])) } } all_point=mutate(all_point, geometry=st_as_sfc(paste0(&quot;POINT(&quot;, X, &quot; &quot;, Y, &quot;)&quot;)))%&gt;% st_sf(crs=3826) tm_shape(bus_shape_temp)+ tm_lines()+ tm_shape(bus_stop_temp)+ tm_dots()+ tm_shape(all_point)+ tm_dots(col=&quot;blue&quot;) 步驟三：計算各路線切分點之間的距離與累積里程 將所有路線的點萃取完成後，即可計算每一個點的累積里程。事實上 GTFS 資料即是透過這樣的方式建立資料，故若未來 TDX 可提供「符合國際公定標準」的公共運輸資料格式，則本演算法無須如此複雜。 圖 7.4: 累積里程計算示意圖 # 計算各點之間的距離與累積里程 dist_point=as.numeric(st_distance(all_point[1:(nrow(all_point)-1),], all_point[2:(nrow(all_point)),], by_element=T)) all_point$Dist_Cum=c(0, mapply(function(x) sum(dist_point[1:x]), c(1:length(dist_point)))) head(all_point) ## Simple feature collection with 6 features and 3 fields ## Geometry type: POINT ## Dimension: XY ## Bounding box: xmin: 328503.4 ymin: 2781112 xmax: 328521.4 ymax: 2781150 ## Projected CRS: TWD97 / TM2 zone 121 ## X Y geometry Dist_Cum ## 1 328503.4 2781112 POINT (328503.4 2781112) 0.000000 ## 2 328507.0 2781120 POINT (328507 2781120) 8.361598 ## 3 328510.6 2781127 POINT (328510.6 2781127) 16.723196 ## 4 328514.2 2781135 POINT (328514.2 2781135) 25.084795 ## 5 328517.8 2781142 POINT (328517.8 2781142) 33.446393 ## 6 328521.4 2781150 POINT (328521.4 2781150) 41.807991 步驟四：計算原始公車站牌與路線切分點間的距離關係 計算原始公車站牌與路線切分點兩圖資間各點的距離，並挑選可匹配的候選點。為避免擷取過多資料運算，在此僅挑選鄰近站牌 30 公尺以內作為候選點。 圖 7.5: 計算站牌與切分點間之距離示意圖 # 計算站點與候選點間距離並給定標籤(只篩選小於30公尺者) min_ret=function(x, y){ Dist=x[x&lt;30] Seq=which(x&lt;30) if(length(Dist)==0){ Dist=min(x) Seq=which.min(x) } return(list(Dist=Dist, Seq=Seq)) } # 計算各點之間的距離與累積里程 all_dist=as.matrix(st_distance(bus_stop_temp, all_point)) all_dist_poss=apply(all_dist, 1, min_ret) # 查看第一個站牌的距離與配對的候選點 all_dist_poss[[1]] ## $Dist ## [1] 2.709508 8.744778 16.894777 25.183894 28.272711 ## ## $Seq ## [1] 1 2 3 4 1538 由以上回傳資料可知，第一個站牌鄰近 30 公尺內的候選點共 5 個，為切分點資料的第 1、2、3、4、1538 筆資料（$Seq之標籤），而其距離存於$Dist之標籤中。 步驟五：演算法尋找最可能匹配點位 此一步驟為本演算法的核心，係利用 Hidden Markov Model 之地圖匹配法，此一演算法大量應用於 GPS 或信令資料的地圖匹配程序中。其中機率分為 emission probability 與 transition probability。前者為打點位置與候選點間匹配的機率，若兩者直線距離愈大，機率愈低，於本案例中即是公車站牌至鄰近公車路線上候選點間的距離，若距離愈大機率即愈低。後者則為打點位置所匹配之候選點轉移至下一個候選點的機率，通常是兩者的距離愈短，機率愈高。Hidden Markov Model 照理而言是動態的模型，前一次的決定會影響後者，故演算法甚為複雜。而由於本案例中公車站牌數化的飄移位置並不大，且其所對應的公車路線亦已存在出現次序，故可單純利用貪婪（myopic）的方式，將每一公車站牌當下的 emission probability 與 transition probability 相乘取最大之機率值作為最終候選點即可。 圖 7.6: 尋找最可能匹配點位示意圖 # 演算法尋找最可能匹配點位(類似Hidden Markov Model) all_seq=c() step_seq=0 for(m in c(1:length(all_dist_poss))){ emis_prob=abs(1/all_dist_poss[[m]]$Dist) trans_prob=1/(all_dist_poss[[m]]$Seq-step_seq) step_seq=all_dist_poss[[m]]$Seq[which.max(emis_prob*trans_prob)] all_seq=c(all_seq, step_seq) } print(all_seq) ## [1] 1 23 57 86 105 134 174 228 275 360 387 416 437 475 500 ## [16] 540 581 603 637 659 705 776 821 882 909 957 976 1008 1028 1062 ## [31] 1082 1115 1144 1177 1239 1256 1286 1324 1387 1427 1450 1469 1486 1515 1538 此一順序即是對照公車路線切分點的資料，如第一個公車站牌所對應的數值為 1，意指該公車站牌應匹配至切分點的第 1 筆資料；又如第二個公車站牌所對應的數值為 23，意指該公車站牌應匹配至切分點的第 23 筆資料，以此類推。 步驟六：將匹配點位貼附於原始公車資料中 最後把前一步驟結果的候選點合併至原始的公車站牌中，並透過累積里程計算兩站點間旅行距離。 # 將匹配點位貼附於原始公車資料中 bus_stop_temp_rev=cbind(st_drop_geometry(bus_stop_temp), all_point[all_seq,])%&gt;% st_sf(crs=3826) # 透過累積里程計算兩站點間距離 bus_stop_temp_rev$Dist_Intv=c(NA, bus_stop_temp_rev$Dist_Cum[c(2:nrow(bus_stop_temp_rev))]-bus_stop_temp_rev$Dist_Cum[c(1:nrow(bus_stop_temp_rev)-1)]) tm_shape(bus_shape_temp)+ tm_lines()+ tm_shape(bus_stop_temp)+ tm_dots()+ tm_shape(bus_stop_temp_rev)+ tm_dots(col=&quot;red&quot;) 地圖中紅色點表示最終匹配的點位，所有點位必定落於公車路線上。最終結果匯出如下表所示。其中Dist_Cum是站點累積里程，Dist_Intv是該站與前一站之間的路網距離。 完整程式碼請參見此。 "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
